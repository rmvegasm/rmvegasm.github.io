{"title":"A rudimentary wordcloud from twitter data","markdown":{"yaml":{"title":"A rudimentary wordcloud from twitter data","categories":["R","wordcloud","rtweet","tutorial"],"date":"2022/09/17"},"headingText":"Accessing twitter from R","containsRefs":false,"markdown":"\n\nIn this post I'll build a wordcloud from twitter texts. I'll be using the\namazing [rtweet][rtweet] package to access the [twitter API][twitterAPI]. At the\ntime of writing, rtweet can only acces the version 1 of the API, from which\nthere is possible to obtain a single table with the query results. Version 2\nallows for much more control on the query output but is not yet implemented in\nrtweet and I wanted to try it out ;)\n\nThe wordcloud is a powerfull way to visualize word frequencies in a text and\ngrasp something about the topics covered within. To build it we need a list of\nwords and the frequency for each of them. There is much more than it seems to\nthis, but as a first *naive* approximation one could just separate each document\ninto single words and build a table from that. This is exactly what this post\nwill cover.\n\n\nThe twitter API offers extensive functionality to query *tweets*, with different\nlevels of access according to your account type. For this exercise we only need\nthe most basic level, basically we want to download a certain ammount of\n*tweets* that match a *string*. This is the same thing as opening the app on\nyour phone and *searching* for a keyword. We don't need to register an app for\nthis (using v.1), and rtweet provides a handy function to authenticate the\n*currently logged-in user* and store the relevant info for future sessions.\nWe'll be using this method as this is a one-time query.\n\n```{r}\nlibrary('rtweet')\n# Authenticate the currently logged-in user and store credentials, this needs to\n# be done only once per machine:\n# rtweet::auth_setup_default()\n\n# Do not perform query if results are already stored:\ntbl_file = 'tweets_tbl.rds'\ntweets_file = 'tweets.csv'\n\nif (file.exists(tweets_file)) {\n  tweets = read.csv(tweets_file)\n} else {\n  tweets = rtweet::search_tweets(\n    'chile -filter:quote -filter:media lang:es',\n    n = 2000,\n    include_rts = FALSE,\n    retryonratelimit = TRUE\n  )\n  # let's save the tibble just in case and write a csv ommiting list cols\n  saveRDS(tweets, tbl_file)\n  tweets = tweets[, sapply(tweets, class) != 'list'] |> as.data.frame()\n  write.csv(tweets, tweets_file, row.names = FALSE)\n}\n```\n\nLet's take a look at what we got:\n\n```{r, purl = FALSE}\nstr(tweets, give.attr = FALSE)\n```\n\nLet's now have a look at a sample text. The most *retweeted* text is:\n\n```{r, purl = FALSE}\nwith(tweets, full_text[which.max(retweet_count)]) |>\n  strwrap() |>\n  cat(fill = TRUE)\n```\n\nThere's something here that is not a word but a *link*. This is rather common\nnowadays, text is mingled with *links*, *hashtags*, *mentions* and other things.\nThis will be a problem if we treat them as just another word. Let's create a\nsample text that has all of these things:\n\n```{r, purl = FALSE}\ntx = 'Hola @persona, este mensaje no tiene otro objetivo que ayudarnos\na filtrar cosas que no son palabras. 3215. https://aquinoes.cl #aquitampoco'\n```\n\nWe can use this sample as a test case and see if we're able to get a word count\nfor *meaningful* words. If this was only regular text the task would reduce to\nsplitting by words, removing punctuation characters, adjusting capitalization\nand counting; but having these *things-that-are-not-a-word* we'll instead need to:\n\n1. split by words\n1. remove *links*\n1. remove *hashtags*\n1. remove *mentions* (e.g. `'@camara_cl'`)\n1. remove *punctuation* and other non alphabetic characters\n1. remove any *empty string* left\n\nLet's start by splitting:\n\n```{r, purl = FALSE}\nstrsplit(tx, '[[:space:]]')\n```\n\nNote that `strsplit()` returns a `list`. This will be the starting point when\nprocessing all the *tweets*, so for now we'll focus on the only element of this\nlist:\n\n```{r, purl = FALSE}\ntx = strsplit(tx, '[[:space:]+]')[[1L]]\ntx\n```\n\nBefore we remove non alpha-numeric characters we'll want to get rid of *links*,\n*hashtags* and *mentions*, since these are defined by such characters. For\nconsistency we'll treat numbers also here:\n\n```{r}\nis_link = function (x) grepl('^[[:lower:]]+://.+', x)\nis_hashtag = function (x) grepl('^#.+', x)\nis_mention = function (x) grepl('^@.+', x)\nis_number = function (x) grepl('^[[:digit:]]+[[:punct:]]*$', x)\n```\n\nLet's see if these work:\n\n```{r, purl = FALSE}\ntx[is_link(tx)]\ntx[is_hashtag(tx)]\ntx[is_mention(tx)]\ntx[is_number(tx)]\n```\n\nNailed it. Now it's easy to remove these things:\n\n```{r, purl = FALSE}\ntx = tx[!is_link(tx)]\ntx = tx[!is_hashtag(tx)]\ntx = tx[!is_mention(tx)]\ntx = tx[!is_number(tx)]\ntx\n```\n\nThis looks good, now let's remove *punctuation* and anything that is not an\nalpha-numeric character:\n\n```{r, purl = FALSE}\ntx = lapply(tx, gsub, pattern = '[^[:alnum:]]', replacement = '') |> unlist()\ntx\n```\n\nFinally, let's filter out any empty strings and get everything to lower case:\n\n```{r, purl = FALSE}\ntx = tx[tx != ''] |> tolower()\ntx\n```\n\nSince we'll be doing this same procedure to every *tweet* the cleanest way would\nbe to pack it all into a function we can `apply` over the *tweets* vector:\n\n```{r}\nextract_words = function (x) {\n  x = x[!is_link(x)]\n  x = x[!is_hashtag(x)]\n  x = x[!is_mention(x)]\n  x = x[!is_number(x)]\n  x = lapply(x, gsub, pattern = '[^[:alnum:]]', replacement = '') |> unlist()\n  x = x[x != '']\n  tolower(x)\n}\n```\n\nWith this function we can *cleanse* every tweet in a single call to `lapply`:\n\n```{r purl = FALSE}\ntweets[['full_text']] |> strsplit(split = '[[:space:]]') |> lapply(extract_words) |> head()\n```\n\nNow we have a list of character vectors containing only words, but most of those\nword aren't *meaningful*. For this post we'll use a rough hack and just filter\nthose words that have between 5 and 10 characters. This will almost certainly\ncrop all short illatives such as *de*, *y*, *para*; but is by no means a proper\nway of ensuring we're left with all *meaninful* words (I'm sure *god* would\nagree that at the *end* the value of a *word* is not given by it's number of\ncharacters).  That said, let's get into it:\n\n```{r}\nclean_tweets = tweets[['full_text']] |>\n  strsplit(split = '[[:space:]+]') |>\n  lapply(extract_words)\n\nwords = lapply(clean_tweets, function (x) {\n  n = nchar(x)\n  x[n >= 5 & n <= 10]\n})\n\nword_bag = unlist(words)\n```\n\nLet's take a look at the 12 most frequent words:\n\n```{r, purl = FALSE}\ntable(word_bag) |> sort(decreasing = TRUE) |> head(n = 13)\n```\n\nThe most frequent word is the one we used for the query, which is to be expected\nand gives us no info about the topics being commented. We should by all means\nremove this word:\n\n```{r}\nword_bag = local({\n  query = 'chile'\n  word_bag[!(word_bag %in% query)]\n})\n```\n\nNow this is boring, since we're leaving out all semantic structure and treating\ntext as a *word bag* we should at least make it look beautiful. By far the most\ncompelling visualization for word fequencies is the *wordcloud*. We'll use the\n[wordcloud2][wordcloud2] package along the [wesanderson][wesanderson] color\npalettes to build one. Wordcloud's  main function expects a `data.frame` with\n`word` and `freq` as columns, so let's construct that from our *word bag* and\ngenerate a cloud:\n\n```{r}\nlibrary('wordcloud2')\nlibrary('wesanderson')\n\nwf = local({\n  wb = table(word_bag)\n  word = names(wb)\n  freq = as.numeric(wb)\n  data.frame(word, freq)[freq >= 10, ]\n})\n\n# Nice colors from 'The Darjeeling Express'\nclrs = rep(wesanderson::wes_palette('Darjeeling1', 5), length.out = nrow(wf))\n\nwordcloud2::wordcloud2(wf,\n  background = 'transparent',\n  color = clrs,\n  size = .3)\n```\n\n## Write a summary and conclusion here\n\n```{r, include = FALSE, purl = FALSE}\nknitr::purl('index.qmd', output = 'script.r')\n```\n\n---\n\n```{r filename = 'Complete Code', file = 'script.r', eval = FALSE, purl = FALSE}\n\n```\n\n[wordcloud2]: https://cran.r-project.org/web/packages/wordcloud2/vignettes/wordcloud.html\n[twitterAPI]: https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwjiqurGgOj6AhWdDLkGHfjBBRcQFnoECA8QAQ&url=https%3A%2F%2Fdeveloper.twitter.com%2Fen%2Fdocs%2Ftwitter-api&usg=AOvVaw07KoWHf5ew9enXbRwVd6eq\n[rtweet]: https://github.com/ropensci/rtweet\n[wesanderson]: https://github.com/karthik/wesanderson\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.189","theme":{"dark":["darkly","../../../custom.scss"],"light":["flatly","../../../custom.scss"]},"title-block-banner":true,"title":"A rudimentary wordcloud from twitter data","categories":["R","wordcloud","rtweet","tutorial"],"date":"2022/09/17"},"extensions":{"book":{"multiFile":true}}}}}